#!/usr/bin/env python

"""
Data fitting program

A GUI-version program for spectra fitting
"""

from __future__ import print_function

__author__ = "LI Kezhi"
__date__ = "$2017-11-30$"
__version__ = "0.1"

import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt

import numpy as np
from scipy import integrate
from scipy.integrate import simps
from lmfit.models import VoigtModel, LinearModel, PolynomialModel
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg
# implement the default mpl key bindings
from matplotlib.backend_bases import key_press_handler
from matplotlib.figure import Figure

import sys
if sys.version_info[0] < 3:
    import Tkinter as Tk
    import tkMessageBox
else:
    import tkinter as Tk

from FileDialog import LoadFileDialog


root = Tk.Tk()
root.wm_title("Data ftting")


# Default plotting
fig = Figure(figsize=(5, 4), dpi=100)
axe = fig.add_subplot(111)


# a tk.DrawingArea
figWindow = []
canvas = []
toolbar = []
def createFigWindow(fig):
    '''
    A general method to create a new window for plotting
    Input: fig generated by pyplot
    '''
    figWindow.append(Tk.Tk())
    figIndex = len(figWindow)
    figWindow[-1].wm_title('Figure ' + str(figIndex))
    figWindow[-1].geometry('650x500+500+200')  # To avoid unstable size refreshing
    canvas.append(FigureCanvasTkAgg(fig, figWindow[-1]))
    canvas[-1].show()
    canvas[-1].get_tk_widget().pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)

    toolbar.append(NavigationToolbar2TkAgg(canvas[-1], figWindow[-1]))
    toolbar[-1].update()
    canvas[-1]._tkcanvas.pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)

    return figWindow[-1], canvas[-1], toolbar[-1]

# Initial plotting window
axe.text(0.3, 0.5, 'Welcome to use this plotting script!')
createFigWindow(fig)

##### Open files #####
fileLabelFrame = Tk.LabelFrame(root, text='Step 1: Select a data file')
fileLabelFrame.pack(side=Tk.TOP, fill=Tk.X)
filename = Tk.StringVar(root)
def openFile():
    '''
    Open a file for inspection
    Effect: open the file in a new window
    Return: the route of the file
    '''
    global filename
    fd = LoadFileDialog(fileButton)
    filename = fd.go()
    text = open(filename, 'r').read()
    newWindow = Tk.Tk()
    newWindow.wm_title('Preview')
    preview = Tk.Text(newWindow, width=80, height=40, wrap=Tk.NONE)
    scrollbarX = Tk.Scrollbar(newWindow, orient=Tk.HORIZONTAL)
    scrollbarY = Tk.Scrollbar(newWindow, orient=Tk.VERTICAL)
    scrollbarX.pack(side=Tk.BOTTOM, fill=Tk.X)
    scrollbarY.pack(side=Tk.RIGHT, fill=Tk.Y)
    preview.config(xscrollcommand=scrollbarX.set)
    preview.config(yscrollcommand=scrollbarY.set)
    scrollbarX.config(command=preview.xview)
    scrollbarY.config(command=preview.yview)
    preview.pack(fill=Tk.BOTH)
    preview.insert(Tk.INSERT, str(text))
fileButton = Tk.Button(fileLabelFrame, text='Open...', command=openFile)
fileButton.pack(side=Tk.LEFT)


##### Plot #####
plotLabelFrame = Tk.LabelFrame(root, text='Step 2: Set plotting paramaters')
plotLabelFrame.pack(side=Tk.TOP, fill=Tk.X)
# Parameter: rows to skip
skipRowsFrame = Tk.Frame(plotLabelFrame)
skipRowsFrame.pack(side=Tk.TOP)
Tk.Label(skipRowsFrame, text='Lines to skip: ').pack(side=Tk.LEFT)
vSkipRows = Tk.IntVar(root)
vSkipRows.set(0)
entrySkipRows = Tk.Entry(skipRowsFrame, textvariable=vSkipRows, width=4)
entrySkipRows.pack(side=Tk.LEFT)

# Parameter: delimiter
delimiterFrame = Tk.Frame(plotLabelFrame)
delimiterFrame.pack(side=Tk.TOP)
Tk.Label(delimiterFrame, text='Delimiter: ').pack(side=Tk.LEFT)
vDelimiter = Tk.StringVar()
r1 = Tk.Radiobutton(delimiterFrame, text="Space/Tab", variable=vDelimiter, value='space')
r2 = Tk.Radiobutton(delimiterFrame, text="Comma", variable=vDelimiter, value='comma')
r1.select()
r2.deselect()
r1.pack(side=Tk.LEFT)
r2.pack(side=Tk.LEFT)

# Parameter: columns to draw
columnFrame = Tk.Frame(plotLabelFrame)
columnFrame.pack(side=Tk.TOP)
Tk.Label(columnFrame, text='Column number of x: ').pack(side=Tk.LEFT)
vColumnX = Tk.IntVar(root)
entryColumnX = Tk.Entry(columnFrame, textvariable=vColumnX, width=4)
vColumnX.set(1)
entryColumnX.pack(side=Tk.LEFT)
Tk.Label(columnFrame, text='Column number of y: ').pack(side=Tk.LEFT)
vColumnY = Tk.IntVar(root)
entryColumnY = Tk.Entry(columnFrame, textvariable=vColumnY, width=4)
vColumnY.set(2)
entryColumnY.pack(side=Tk.LEFT)

# Plot
def plot_data():
    '''
    A general method to plot the figure and create a new window to display
    '''
    # print(filename)
    if vDelimiter.get() == 'space':
        delimiter = None
    elif vDelimiter.get() == 'comma':
        delimiter = ','
    data = np.loadtxt(filename, skiprows=vSkipRows.get(), delimiter=delimiter)
    fig = Figure(figsize=(5, 4), dpi=100)
    axe = fig.add_subplot(111)
    axe.scatter(data[:, vColumnX.get()-1], data[:, vColumnY.get()-1])
    figWindowNew, canvasNew, toolbarNew = createFigWindow(fig)
    canvasNew.show()
    toolbarNew.update()
    # canvas._tkcanvas.pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)
    figWindowNew.wm_attributes('-topmost')  # Activate the plotting window

buttonReadData = Tk.Button(plotLabelFrame, text='Plot', command=plot_data)
buttonReadData.pack(side=Tk.TOP)


##### Background #####
bgLabelFrame = Tk.LabelFrame(root, text='Step 3: Determine the background')
bgLabelFrame.pack(side=Tk.TOP, fill=Tk.X)
# Parameter: fitting range
rangeFrame = Tk.Frame(bgLabelFrame)
rangeFrame.pack(side=Tk.TOP)

rangeStartFrame = Tk.Frame(rangeFrame)
rangeStartFrame.pack(side=Tk.TOP, anchor=Tk.W)
Tk.Label(rangeStartFrame, text='Background - Left zone:').pack(side=Tk.TOP, anchor=Tk.W)
Tk.Label(rangeStartFrame, text='x: from ').pack(side=Tk.LEFT)
vStartLeftX = Tk.DoubleVar(root)
entryStartLeftX = Tk.Entry(rangeStartFrame, textvariable=vStartLeftX, width=6)
entryStartLeftX.pack(side=Tk.LEFT)
Tk.Label(rangeStartFrame, text=' to ').pack(side=Tk.LEFT)
vStartRightX = Tk.DoubleVar(root)
entryStartRightX = Tk.Entry(rangeStartFrame, textvariable=vStartRightX, width=6)
entryStartRightX.pack(side=Tk.LEFT)

rangeEndFrame = Tk.Frame(rangeFrame)
rangeEndFrame.pack(side=Tk.TOP, anchor=Tk.W)
Tk.Label(rangeEndFrame, text='Background - Right zone:').pack(side=Tk.TOP, anchor=Tk.W)
Tk.Label(rangeEndFrame, text='x: from ').pack(side=Tk.LEFT)
vEndLeftX = Tk.DoubleVar(root)
entryEndLeftX = Tk.Entry(rangeEndFrame, textvariable=vEndLeftX, width=6)
entryEndLeftX.pack(side=Tk.LEFT)
Tk.Label(rangeEndFrame, text=' to ').pack(side=Tk.LEFT)
vEndRightX = Tk.DoubleVar(root)
entryEndRightX = Tk.Entry(rangeEndFrame, textvariable=vEndRightX, width=6)
entryEndRightX.pack(side=Tk.LEFT)

# Parameter: background form
bgFormFrame = Tk.Frame(bgLabelFrame)
bgFormFrame.pack(side=Tk.TOP)
Tk.Label(bgFormFrame, text='Background line shape: 1 for linear, 2 for parabola and n for higher rank polynomial').pack(side=Tk.TOP)
Tk.Label(bgFormFrame, text='Choice: ').pack(side=Tk.LEFT)
vPolynomial = Tk.IntVar(root)
vPolynomial.set(1)
entryPolynomial = Tk.Entry(bgFormFrame, textvariable=vPolynomial, width=4)
entryPolynomial.pack(side=Tk.LEFT)

def select_bg_data(data, selectRange):
    '''
    Select the data in a given range
    Input:
    data - a 2-colomn array
    selectRange - 4 points
    Output:
    outdata
    '''
    startLine1, startLine2 = None, None
    endLine1, endLine2 = None, None
    head1 = selectRange[0]
    head2 = selectRange[1]
    end1 = selectRange[2]
    end2 = selectRange[3]
    for i in xrange(data.shape[0]):
        if data[i, 0] >= head1 and startLine1 is None:
            startLine1 = i
        if startLine1 != None and startLine2 is None and data[i, 0] >= head2:
            startLine2 = i
        if data[i, 0] >= end1 and endLine1 is None:
            endLine1 = i
        if endLine1 != None and endLine2 is None and data[i, 0] >= end2:
            endLine2 = i
    x_bg = np.hstack((data[:, 0][startLine1:startLine2],
                      data[:, 0][endLine1:endLine2]))
    y_bg = np.hstack((data[:, 1][startLine1:startLine2],
                      data[:, 1][endLine1:endLine2]))
    return [x_bg, y_bg]

def fit_background():
    '''
    Fit the background
    '''
    bg_mod = PolynomialModel(vPolynomial.get(), prefix='bg_')   # Background
    if vDelimiter.get() == 'space':
        delimiter = None
    elif vDelimiter.get() == 'comma':
        delimiter = ','
    data = np.loadtxt(filename, skiprows=vSkipRows.get(), delimiter=delimiter)
    original_data = np.vstack((data[:, vColumnX.get()-1], data[:, vColumnY.get()-1])).T
    selectionRange = (vStartLeftX.get(), vStartRightX.get(), vEndLeftX.get(), vEndRightX.get())

    x_bg, y_bg = select_bg_data(original_data, selectionRange)

    pars = bg_mod.guess(y_bg, x=x_bg)
    mod = bg_mod
    init = mod.eval(pars, x=x_bg)
    out = mod.fit(y_bg, pars, x=x_bg)

    axe.cla()
    axe.plot(data[:, vColumnX.get()-1], data[:, vColumnY.get()-1], 'b.')
    axe.plot(x_bg, out.eval(), 'r-')    # Background plotting
    # axe.xlim([original_data[0, 0], original_data[1, -1]])
    figWindowNew, canvasNew, toolbarNew = createFigWindow(fig)
    canvasNew.show()
    toolbarNew.update()
    # canvas._tkcanvas.pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)
    figWindowNew.wm_attributes('-topmost')  # Activate the plotting window

buttonReadData = Tk.Button(bgLabelFrame, text='Fit background', command=fit_background)
buttonReadData.pack(side=Tk.TOP)


##### Fitting parameters #####
peakNumLabelFrame = Tk.LabelFrame(root, text='Step 4: Determine the number of peaks')
peakNumLabelFrame.pack(side=Tk.TOP, fill=Tk.X)
peakNumber = Tk.IntVar(root)
peakNumber.set(1) # default value
Tk.Label(peakNumLabelFrame, text='Number of peaks: ').pack(side=Tk.LEFT)
peakNumberChoices = (1, 2, 3, 4, 5)
peakNumberOption = Tk.OptionMenu(peakNumLabelFrame, peakNumber, *peakNumberChoices)
peakNumberOption.pack(side=Tk.LEFT)
# The below lines are put at the end
# buttonPeakNumber = Tk.Button(peakNumLabelFrame, text='Enter', command=lambda :1)
# buttonPeakNumber.pack(side=Tk.LEFT)


##### Peak parameters #####
peakParFrames = []
peakParBgFrame = Tk.Frame(root)
peakParBgFrame.pack(side=Tk.TOP)
def generateStep5():
    if len(peakParFrames) > 0:
        peakParFrames[-1].destroy()
    peakParLabelFrame = Tk.LabelFrame(peakParBgFrame, text='Step 5: Peak parameters')
    peakParFrames.append(peakParLabelFrame)
    peakParLabelFrame.pack(side=Tk.TOP, fill=Tk.X)

    numPeaks = peakNumber.get()
    peakCenter = []
    peakAmplitude = []
    peakSigma = []
    peakGLRatio = []
    entryCenter = []
    entryAmplitude = []
    entrySigma = []
    entryGLRatio = []
    PEAK_NAMES = []

    for i in xrange(numPeaks):
        PEAK_NAMES.append('Peak_' + str(i))

        peakCenter.append(Tk.DoubleVar(root))
        peakCenter[i].set(0)
        peakAmplitude.append(Tk.DoubleVar(root))
        peakAmplitude[i].set(1)
        peakSigma.append(Tk.DoubleVar(root))
        peakSigma[i].set(1)
        peakGLRatio.append(Tk.DoubleVar(root))
        peakGLRatio[i].set(0.8)
        peakInfoFrame = Tk.LabelFrame(peakParLabelFrame, text='Peak ' + str(i+1))
        peakInfoFrame.pack(side=Tk.TOP)
        Tk.Label(peakInfoFrame, text='Center: ').pack(side=Tk.LEFT)
        entryCenter.append(Tk.Entry(peakInfoFrame, textvariable=peakCenter[i], width=6))
        entryCenter[i].pack(side=Tk.LEFT)
        Tk.Label(peakInfoFrame, text='Amplitude: ').pack(side=Tk.LEFT)
        entryAmplitude.append(Tk.Entry(peakInfoFrame, textvariable=peakAmplitude[i], width=6))
        entryAmplitude[i].pack(side=Tk.LEFT)
        Tk.Label(peakInfoFrame, text='Sigma: ').pack(side=Tk.LEFT)
        entrySigma.append(Tk.Entry(peakInfoFrame, textvariable=peakSigma[i], width=6))
        entrySigma[i].pack(side=Tk.LEFT)
        Tk.Label(peakInfoFrame, text='Gauss/Lorentz: ').pack(side=Tk.LEFT)
        entryGLRatio.append(Tk.Entry(peakInfoFrame, textvariable=peakGLRatio[i], width=6))
        entryGLRatio[i].pack(side=Tk.LEFT)

    def fit_preview():
        '''
        The fitting-preview function
        '''
        bg_mod = PolynomialModel(vPolynomial.get(), prefix='bg_')   # Background
        if vDelimiter.get() == 'space':
            delimiter = None
        elif vDelimiter.get() == 'comma':
            delimiter = ','
        data = np.loadtxt(filename, skiprows=vSkipRows.get(), delimiter=delimiter)
        original_data = np.vstack((data[:, vColumnX.get()-1], data[:, vColumnY.get()-1])).T
        selectionRange = (vStartLeftX.get(), vStartRightX.get(), vEndLeftX.get(), vEndRightX.get())

        x = data[:, vColumnX.get()-1]
        y = data[:, vColumnY.get()-1]
        x_bg, y_bg = select_bg_data(original_data, selectionRange)

        # Background fitting
        pars = bg_mod.guess(y_bg, x=x_bg)
        mod = bg_mod
        init = mod.eval(pars, x=x_bg)
        out = mod.fit(y_bg, pars, x=x_bg)
        pars = out.params

        # Peak fitting
        peaks = []
        peakParameters = {}
        for i, peak in enumerate(PEAK_NAMES):
            peakParameters[peak] = {}
            peakParameters[peak]['center'] = peakCenter[i].get()
            peakParameters[peak]['amplitude'] = peakAmplitude[i].get()
            peakParameters[peak]['sigma'] = peakSigma[i].get()
        mod = bg_mod
        for i, peak in enumerate(PEAK_NAMES):
            peaks.append(VoigtModel(prefix=peak))  # Peak information
            pars.update(peaks[i].make_params())

            pars[peak + 'center'].set(
                peakParameters[peak]['center']
                # peakParameters[peak]['center'][0],
                # min=peakParameters[peak]['center'][1],
                # max=peakParameters[peak]['center'][2]
                )
            pars[peak + 'amplitude'].set(
                peakParameters[peak]['amplitude']
                # peakParameters[peak]['amplitude'][0],
                # min=peakParameters[peak]['amplitude'][1]
                )
            pars[peak + 'sigma'].set(
                peakParameters[peak]['sigma']
                # peakParameters[peak]['sigma'][0],
                # min=peakParameters[peak]['sigma'][1],
                # max=peakParameters[peak]['sigma'][2]
                )

            mod += peaks[i]

        init = mod.eval(pars, x=x) # Initial guess
        axe.cla()
        axe.plot(x, y, 'b.')
        axe.plot(x, init, 'k--')
        figWindowNew, canvasNew, toolbarNew = createFigWindow(fig)
        canvasNew.show()
        toolbarNew.update()
        figWindowNew.wm_attributes('-topmost')  # Activate the plotting window

    def fit_spectra():
        '''
        The fitting function
        '''
        bg_mod = PolynomialModel(vPolynomial.get(), prefix='bg_')   # Background
        if vDelimiter.get() == 'space':
            delimiter = None
        elif vDelimiter.get() == 'comma':
            delimiter = ','
        data = np.loadtxt(filename, skiprows=vSkipRows.get(), delimiter=delimiter)
        original_data = np.vstack((data[:, vColumnX.get()-1], data[:, vColumnY.get()-1])).T
        selectionRange = (vStartLeftX.get(), vStartRightX.get(), vEndLeftX.get(), vEndRightX.get())

        fittingRange = (vStartLeftX.get(), vEndRightX.get(), vEndRightX.get(), vEndRightX.get())

        # x = data[:, vColumnX.get()-1]
        # y = data[:, vColumnY.get()-1]
        x_bg, y_bg = select_bg_data(original_data, selectionRange)
        x, y = select_bg_data(original_data, fittingRange)

        # Background fitting
        pars = bg_mod.guess(y_bg, x=x_bg)
        mod = bg_mod
        init = mod.eval(pars, x=x_bg)
        out = mod.fit(y_bg, pars, x=x_bg)
        pars = out.params

        # Peak fitting
        peaks = []
        peakParameters = {}
        for i, peak in enumerate(PEAK_NAMES):
            peakParameters[peak] = {}
            peakParameters[peak]['center'] = peakCenter[i].get()
            peakParameters[peak]['amplitude'] = peakAmplitude[i].get()
            peakParameters[peak]['sigma'] = peakSigma[i].get()
        mod = bg_mod
        for i, peak in enumerate(PEAK_NAMES):
            peaks.append(VoigtModel(prefix=peak))  # Peak information
            pars.update(peaks[i].make_params())

            pars[peak + 'center'].set(
                peakParameters[peak]['center']
                # peakParameters[peak]['center'][0],
                # min=peakParameters[peak]['center'][1],
                # max=peakParameters[peak]['center'][2]
                )
            pars[peak + 'amplitude'].set(
                peakParameters[peak]['amplitude']
                # peakParameters[peak]['amplitude'][0],
                # min=peakParameters[peak]['amplitude'][1]
                )
            pars[peak + 'sigma'].set(
                peakParameters[peak]['sigma']
                # peakParameters[peak]['sigma'][0],
                # min=peakParameters[peak]['sigma'][1],
                # max=peakParameters[peak]['sigma'][2]
                )

            mod += peaks[i]

        out = mod.fit(y, pars, x=x)  # Fit
        comps = out.eval_components(x=x)
        pars = out.params

        # Update parameters
        for i, peak in enumerate(PEAK_NAMES):
            peakParameters[peak] = {}
            peakParameters[peak]['center'] = pars[peak + 'center'].value
            peakParameters[peak]['amplitude'] = pars[peak + 'amplitude'].value
            peakParameters[peak]['sigma'] = pars[peak + 'sigma'].value
            peakCenter[i].set(peakParameters[peak]['center'])
            peakAmplitude[i].set(peakParameters[peak]['amplitude'])
            peakSigma[i].set(peakParameters[peak]['sigma'])

        axe.cla()
        axe.plot(x, y, 'b.')
        axe.plot(x, out.best_fit, 'r-')  # plot fitting result
        axe.plot(x, comps['bg_'], 'g-')  # plot background and the peaks
        for i, peak in enumerate(PEAK_NAMES):
            axe.plot(x, comps[peak] + comps['bg_'], 'k-')

        figWindowNew, canvasNew, toolbarNew = createFigWindow(fig)
        canvasNew.show()
        toolbarNew.update()
        figWindowNew.wm_attributes('-topmost')  # Activate the plotting window

        # Report
        result_txt = out.fit_report(min_correl=0.5)
        result_txt += '\n'
        result_txt += '===================\n'

        for i, peak in enumerate(PEAK_NAMES):
            area = simps(comps[peak], x)  # Integration results
            result_txt += 'Area ' + repr(i) + ': ' + repr(area) + '\n'

        reportWindow = Tk.Tk()
        reportWindow.wm_title('Report')
        reportFrame = Tk.Frame(reportWindow)
        reportFrame.pack(side=Tk.TOP)
        reportText = Tk.Text(reportFrame, width=80, height=40, wrap=Tk.NONE)
        scrollbarX = Tk.Scrollbar(reportFrame, orient=Tk.HORIZONTAL)
        scrollbarY = Tk.Scrollbar(reportFrame, orient=Tk.VERTICAL)
        scrollbarX.pack(side=Tk.BOTTOM, fill=Tk.X)
        scrollbarY.pack(side=Tk.RIGHT, fill=Tk.Y)
        reportText.config(xscrollcommand=scrollbarX.set)
        reportText.config(yscrollcommand=scrollbarY.set)
        scrollbarX.config(command=reportText.xview)
        scrollbarY.config(command=reportText.yview)
        reportText.pack(fill=Tk.BOTH)
        reportText.insert(Tk.INSERT, result_txt)

        resultFittingData = np.vstack((x, out.data, out.best_fit, comps['bg_'])) # Fitting result
        headerStr = 'x  OriginalData  Fit  Background'
        for i, peak in enumerate(PEAK_NAMES):
            resultFittingData = np.vstack((resultFittingData, comps[peak]))
            headerStr += '  peak' + repr(i)

        graphFit = np.transpose(resultFittingData)

        def save_report():
            resultFile = open(filename + '_result.txt', 'w')
            resultFile.write(result_txt)
            resultFile.close()
            np.savetxt(
                filename + '_graph.txt', graphFit, newline='\n',
                header=headerStr
            )
            if sys.version_info[0] < 3:
                tkMessageBox.showinfo('Message', 'The files are successfully saved as: ' + filename + '_result.txt' + ' and ' + filename + '_graph.txt')

        buttonSave = Tk.Button(reportWindow, text='Save report', command=save_report)
        buttonSave.pack(side=Tk.BOTTOM)


    bottonPeakParFrame = Tk.Frame(peakParLabelFrame)
    bottonPeakParFrame.pack(side=Tk.TOP)
    buttonPreview = Tk.Button(bottonPeakParFrame, text='Preview', command=fit_preview)
    buttonPreview.pack(side=Tk.LEFT)
    buttonFit = Tk.Button(bottonPeakParFrame, text='Fit data', command=fit_spectra)
    buttonFit.pack(side=Tk.LEFT)

# These lines belong to the previous section
generateStep5()
buttonPeakNumber = Tk.Button(peakNumLabelFrame, text='Enter', command=generateStep5)
buttonPeakNumber.pack(side=Tk.LEFT)

##########
def on_key_event(event):
    print('you pressed %s' % event.key)
    key_press_handler(event, canvas, toolbar)

canvas[-1].mpl_connect('key_press_event', on_key_event)


def _quit():
    root.quit()     # stops mainloop
    root.destroy()  # this is necessary on Windows to prevent
                    # Fatal Python Error: PyEval_RestoreThread: NULL tstate



button = Tk.Button(root, text='Quit', command=_quit)
button.pack(side=Tk.TOP)

Tk.mainloop()
# If you put root.destroy() here, it will cause an error if
# the window is closed with the window manager.